
import * as React from 'react';
import * as Immutable from 'immutable';
import * as contentTypes from '../../../data/contentTypes';
import { AppServices } from 'editors/common/AppServices';
import { AppContext } from 'editors/common/AppContext';
import { AbstractContentEditor, AbstractContentEditorProps } from '../common/AbstractContentEditor';
import { Button } from '../common/controls';
import { Choice } from '../common/Choice';
import { DragDropContext } from 'react-dnd';
import { convert } from 'utils/format';

export interface ChoicesProps {
  itemModel: any;
  partModel: any;
  onEdit: (...args: any[]) => any;
  context: AppContext;
  services: AppServices;
  editMode: boolean;
}

export interface ChoicesState {

}

/**
 * The content editor for Choices
 */
export class Choices
  extends React.PureComponent<ChoicesProps, ChoicesState> {

  constructor(props) {
    super(props);

    this.onAddChoice = this.onAddChoice.bind(this);
    this.onChoiceEdit = this.onChoiceEdit.bind(this);
    this.onRemoveChoice = this.onRemoveChoice.bind(this);
    this.onReorderChoices = this.onReorderChoices.bind(this);
  }

  updateChoiceValuesAndRefs(itemModel: contentTypes.MultipleChoice, partModel: contentTypes.Part) {
    const { onEdit } = this.props;

    const choices = itemModel.choices.toArray();

    // update choices and their values and build remapping maps
    let newChoices = Immutable.OrderedMap<string, contentTypes.Choice>();
    let updatedValuesMapping = Immutable.Map<string, string>();
    // let updatedValuesReverseMapping = Immutable.Map<string, string>();

    choices.forEach((choice, index) => {
      updatedValuesMapping = updatedValuesMapping.set(choice.value, convert.toAlphaNotation(index));
      // updatedValuesReverseMapping = updatedValuesReverseMapping.set(
      //   convert.toAlphaNotation(index), choice.value);
      const value = updatedValuesMapping.get(choice.value);
      newChoices = newChoices.set(choice.guid, choice.with({ value }));
    });

    // update responses to new choice values
    let newResponses = Immutable.OrderedMap<string, contentTypes.Response>();
    partModel.responses.forEach((response) => {
      // filter out autogenerated responses
      if (response.name.match(/^AUTOGEN/)) {
        return;
      }

      // parse response matches from comma-seperated string
      let matches = response.match.split(',');
      // remove choices that no longer exist and update all matche references to thier new value
      matches = matches // .filter(m => choices.find(c => m === c.value))
        .map(m => updatedValuesMapping.get(m))
        .filter(m => m);

      // save new remapped matches as comma-seperated string
      newResponses = newResponses.set(
        response.guid,
        response.with({ match: matches.join(',') }),
      );
    });

    onEdit(
      itemModel.with({ choices: newChoices }),
      partModel.with({ responses: newResponses }),
    );
  }

  onAddChoice() {
    const count = this.props.itemModel.choices.size;
    const value = String.fromCharCode(65 + count);

    const choice = new contentTypes.Choice().with({ value });

    const itemModel = this.props.itemModel.with(
      { choices: this.props.itemModel.choices.set(choice.guid, choice) });

    this.props.onEdit(itemModel, this.props.partModel);
  }

  onRemoveChoice(choice: contentTypes.Choice) {
    let { itemModel } = this.props;
    const { partModel } = this.props;

    itemModel = itemModel.with({
      choices: itemModel.choices.delete(choice.guid),
    });

    // update models with new choices and references
    this.updateChoiceValuesAndRefs(itemModel, partModel);
  }

  onReorderChoices(originalIndex, newIndex) {
    const { onEdit, itemModel, partModel } = this.props;

    // indexOffset makes up for the missing item in the list when splicing,
    // this is only an issue if the new item position is less than the current one
    const indexOffset = originalIndex > newIndex ? 1 : 0;

    // convert OrderedMap to shallow javascript array
    const choices = itemModel.choices.toArray();

    // remove selected choice from array and insert it into new position
    const choice = choices.splice(originalIndex, 1)[0];
    choices.splice(newIndex + indexOffset, 0, choice);

    // update item model
    const updatedItemModel = itemModel.with({
      // set choices to a new OrderedMap with updated choice ordering
      choices: choices.reduce(
        (acc, c) => {
          return acc.set(c.guid, c);
        },
        Immutable.OrderedMap<string, Choice>(),
      ),
    });

    // update models with new choices and references
    this.updateChoiceValuesAndRefs(updatedItemModel, partModel);
  }

  onChoiceEdit(c) {
    this.props.onEdit(
      this.props.itemModel.with(
      { choices: this.props.itemModel.choices.set(c.guid, c) }),
      this.props.partModel);
  }

  renderChoice(choice: contentTypes.Choice, index: number) {
    return (
      <Choice
        key={choice.guid}
        index={index}
        {...this.props}
        model={choice}
        isDraggable={true}
        onDragDrop={this.onReorderChoices}
        onEdit={this.onChoiceEdit}
        onRemove={this.onRemoveChoice.bind(this, choice)}
        />
    );
  }

  render() : JSX.Element {
    const { itemModel, editMode } = this.props;

    return (
      <div className="choices">
      <Button
        editMode={editMode}
        type="link"
        onClick={this.onAddChoice}>
        Add Choice
      </Button>
      {
        itemModel.choices
          .toArray()
          .map((c, i) => this.renderChoice(c, i))
      }
      </div>
    );
  }
}
