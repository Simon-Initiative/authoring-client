import * as React from 'react';
import * as Immutable from 'immutable';
import * as contentTypes from 'data/contentTypes';
import { Choice } from '../common/Choice';
import { FeedbackEditor } from '../part/FeedbackEditor';
import { TextInput, InlineForm, Button } from '../common/controls';
import { HtmlContentEditor } from '../html/HtmlContentEditor';
import InlineInsertionToolbar from '../html/InlineInsertionToolbar';
import InlineToolbar from '../html/InlineToolbar';
import BlockToolbar from '../html/BlockToolbar';
import guid from 'utils/guid';
import { Question, QuestionProps, QuestionState,
 Section, SectionContent, SectionControl, SectionHeader } from './Question';
import {
  InputList, InputListItem, ItemOptions, ItemOption, ItemControl, ItemOptionFlex,
} from 'editors/content/common/InputList.tsx';
import { convert } from 'utils/format';

import './MultipleChoice.scss';

export interface MultipleChoiceProps
  extends QuestionProps<contentTypes.MultipleChoice> {

}

export interface MultipleChoiceState
  extends QuestionState {

}

const HTML_CONTENT_EDITOR_STYLE = {
  minHeight: '20px',
  borderStyle: 'none',
  borderWith: 1,
  borderColor: '#AAAAAA',
};

// tslint:disable-next-line
const ChoiceFeedback = (props) => {
  return (
    <div className="choice-feedback clearfix">
      {props.children}
    </div>
  );
};

export const updateChoiceValuesAndRefs =
  (itemModel: contentTypes.MultipleChoice, partModel: contentTypes.Part, onEdit) => {
    const choices = itemModel.choices.toArray();

    // update choices and their values and build remapping maps
    let newChoices = Immutable.OrderedMap<string, contentTypes.Choice>();
    let updatedValuesMapping = Immutable.Map<string, string>();
    // let updatedValuesReverseMapping = Immutable.Map<string, string>();

    choices.forEach((choice, index) => {
      updatedValuesMapping = updatedValuesMapping.set(choice.value, convert.toAlphaNotation(index));
      // updatedValuesReverseMapping = updatedValuesReverseMapping.set(
      //   convert.toAlphaNotation(index), choice.value);
      const value = updatedValuesMapping.get(choice.value);
      newChoices = newChoices.set(choice.guid, choice.with({ value }));
    });

    // update responses to new choice values
    let newResponses = Immutable.OrderedMap<string, contentTypes.Response>();
    partModel.responses.forEach((response) => {
      // filter out autogenerated responses
      if (response.name.match(/^AUTOGEN/)) {
        return;
      }

      // parse response matches from comma-seperated string
      let matches = response.match.split(',');
      // remove choices that no longer exist and update all matche references to thier new value
      matches = matches // .filter(m => choices.find(c => m === c.value))
        .map(m => updatedValuesMapping.get(m))
        .filter(m => m);

      // save new remapped matches as comma-seperated string
      newResponses = newResponses.set(
        response.guid,
        response.with({ match: matches.join(',') }),
      );
    });

    onEdit(
      itemModel.with({ choices: newChoices }),
      partModel.with({ responses: newResponses }),
    );
  };

/**
 * The content editor for HtmlContent.
 */
export class MultipleChoice
  extends Question<MultipleChoiceProps, MultipleChoiceState> {

  constructor(props) {
    super(props);

    this.setClassname('multiple-choice');

    this.onToggleShuffle = this.onToggleShuffle.bind(this);
    this.onAddChoice = this.onAddChoice.bind(this);
    this.onChoiceEdit = this.onChoiceEdit.bind(this);
    this.onFeedbackEdit = this.onFeedbackEdit.bind(this);
    this.onScoreEdit = this.onScoreEdit.bind(this);
    this.onRemoveChoice = this.onRemoveChoice.bind(this);
    this.onReorderChoices = this.onReorderChoices.bind(this);
  }

  onToggleShuffle() {
    const {
      itemModel,
      partModel,
      onEdit,
    } = this.props;

    onEdit(itemModel.with({ shuffle: !itemModel.shuffle }), partModel);
  }

  onAddChoice() {
    const { partModel, itemModel, onEdit } = this.props;

    const value = guid().replace('-', '');
    const match = value;
    const choice = new contentTypes.Choice({ value });
    const feedback = new contentTypes.Feedback();
    let response = new contentTypes.Response({ match });
    response = response.with({ feedback: response.feedback.set(feedback.guid, feedback) });

    const updatedItemModel = itemModel.with(
      { choices: itemModel.choices.set(choice.guid, choice) });
    const updatedPartModel = partModel.with(
      { responses: partModel.responses.set(response.guid, response) });

    onEdit(updatedItemModel, updatedPartModel);
  }

  onChoiceEdit(c) {
    const { partModel, itemModel, onEdit } = this.props;

    onEdit(
      itemModel.with({
        choices: itemModel.choices.set(c.guid, c),
      }),
      partModel);
  }

  onFeedbackEdit(response : contentTypes.Response, feedback: contentTypes.Feedback) {
    const { partModel, itemModel, onEdit } = this.props;

    const updated = response.with({ feedback: response.feedback.set(feedback.guid, feedback) });
    const part = partModel.with(
      { responses: partModel.responses.set(updated.guid, updated) });
    onEdit(itemModel, part);
  }

  onScoreEdit(response: contentTypes.Response, score: string) {
    const { partModel, itemModel, onEdit } = this.props;

    const updatedScore = response.with({ score });
    const updatedPartModel = partModel.with(
      { responses: partModel.responses.set(updatedScore.guid, updatedScore) },
    );

    onEdit(itemModel, updatedPartModel);
  }

  onRemoveChoice(choice, response) {
    const { partModel, itemModel, onEdit } = this.props;

    const updatedItemModel = itemModel.with(
      { choices: itemModel.choices.delete(choice.guid) });

    let updatePartModel = partModel;
    if (response) {
      updatePartModel = partModel.with(
        { responses: partModel.responses.delete(response.guid) });
    }

    onEdit(updatedItemModel, updatePartModel);
  }

  onReorderChoices(originalIndex, newIndex) {
    const { onEdit, itemModel, partModel } = this.props;

    // indexOffset makes up for the missing item in the list when splicing,
    // this is only an issue if the new item position is less than the current one
    const indexOffset = originalIndex > newIndex ? 1 : 0;

    // convert OrderedMap to shallow javascript array
    const choices = itemModel.choices.toArray();

    // remove selected choice from array and insert it into new position
    const choice = choices.splice(originalIndex, 1)[0];
    choices.splice((newIndex - 1) + indexOffset, 0, choice);

    // update item model
    const updatedItemModel = itemModel.with({
      // set choices to a new OrderedMap with updated choice ordering
      choices: choices.reduce(
        (acc, c) => {
          return acc.set(c.guid, c);
        },
        Immutable.OrderedMap<string, contentTypes.Choice>(),
      ),
    });

    // update models with new choices and references
    updateChoiceValuesAndRefs(updatedItemModel, partModel, onEdit);
  }

  renderChoices() {
    const { context, services, editMode, partModel, itemModel } = this.props;

    const responses = partModel.responses.toArray();
    const choices = itemModel.choices.toArray();

    const renderedChoices = choices.map((choice, i) => {
      const response = responses[i];

      let feedbackEditor;
      let scoreEditor;
      if (response && response.feedback.size > 0) {
        const feedback = response.feedback.first();

        feedbackEditor = (
          <HtmlContentEditor
            editorStyles={HTML_CONTENT_EDITOR_STYLE}
            inlineToolbar={<InlineToolbar/>}
            blockToolbar={<BlockToolbar/>}
            inlineInsertionToolbar={<InlineInsertionToolbar/>}
            {...this.props}
            model={feedback.body}
            onEdit={body => this.onFeedbackEdit(response, feedback.with({ body }))} />
        );

        scoreEditor = (
          <div className="input-group">
            <input
              type="number"
              className="form-control"
              disabled={!editMode}
              value={response.score}
              onChange={({ target: { value } }) =>
                this.onScoreEdit(response, value)
              } />
          </div>
        );
      }

      return (
        <InputListItem
          key={choice.guid}
          className="choice"
          id={choice.guid}
          label={`${i + 1}`}
          context={context}
          services={services}
          editMode={editMode}
          isDraggable={!itemModel.shuffle}
          index={i}
          onDragDrop={this.onReorderChoices}
          body={choice.body}
          onEdit={body => this.onChoiceEdit(choice.with({ body }))}
          onRemove={() => this.onRemoveChoice.bind(this, choice, response)}
          options={
            <ItemOptions>
              <ItemOption className="feedback" label="Feedback" flex>
                {feedbackEditor}
              </ItemOption>
              <ItemOption className="score" label="Score">
                {scoreEditor}
              </ItemOption>
            </ItemOptions>
          } />
      );
    });

    return (
      <InputList className="multiple-choice-choices">
        {renderedChoices}
      </InputList>
    );
  }

  renderAdditionalSections() {
    const { editMode, itemModel, partModel } = this.props;

    return ([
      <Section key="choices" className="choices">
        <SectionHeader title="Choices">
          <SectionControl key="shuffle" name="Shuffle" onClick={this.onToggleShuffle}>
            <input
              className="toggle toggle-light"
              type="checkbox"
              readOnly
              checked={itemModel.shuffle} />
            <label className="toggle-btn"></label>
          </SectionControl>
        </SectionHeader>
        <SectionContent>
          <Button
            editMode={editMode}
            type="link"
            onClick={this.onAddChoice}>
            Add Choice
          </Button>
          {this.renderChoices()}
        </SectionContent>
      </Section>,
    ]);
  }
}
